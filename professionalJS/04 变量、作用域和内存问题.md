# 04 变量、作用域和内存问题

​	ECMAScript变量的本质特点：具有变量松散型的本质特点。

​	这种特点决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必需要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。

## 4.1 基本类型和引用类型的值

​	ECMAScript变量包含两种不同数据类型的值：

- 基本类型值：简单的数据段；
- 引用类型值：由多个值构成的对象。

基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值时保存在内存中的对象。Js不允许直接访问内存中的位置，也就是说不能直接操作对象中的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。

### 4.1.1 动态的属性

定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作时完全不一样的。

- 引用类型：可以为其添加属性和方法，也可以改变和删除其属性和方法。

```javascript
var person = new Object();
person.name = 'li';
alert(person.name);
```

以上代码创建了一个对象并保存在了变量person中。然后，为该变量添加了一个名为name的属性，并将字符串值li赋给了这个属性。紧接着，通过alert()函数访问这个新属性。如果对象不被销毁或这个属性不被删除，则这个属性将一直存在。

- 基本类型：不能给基本类型的值添加属性。

```javascript
var name = 'li';
name.age = 27;
console.log(name.age); // undefined
```

### 4.1.2 赋值变量值

除了保存的方式不同之外，在从一个变量向另一个变量赋值基本类型和引用类型值时，也存在不同。

如果从一个变量向另一个变量复制**基本类型**的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。赋值操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

```javascript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = 'copy obj';
console.log(obj2.name); // copy obj
```

项目里经常遇到这种问题，需要用深拷贝。

### 4.1.3 传递参数

ECMAScript中所有函数的参数都是按值传递的。把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。

访问变量有按值和按引用两种方式，而参数只能按值传递。

### 4.1.4 检测类型

检测基本类型值时，如果变量的值时一个对象或null，则typeof操作符会返回“object”。

在检测引用类型值是，想要知道它是什么类型的对象，可以使用instanceof操作符。

```javascript
result = variable instanceof constructor;
```

注意：

- 如果用instanceof判断一个引用类型值是不是Object ，则永远会返回true。
- 如果用instanceof判断一个值是不是Array，一般没有问题，但是在类的原型继承中，instanceof检测出来的结果并不准确。

## 4.2 执行环境和作用域

执行环境：执行环境定义了变量或函数有权访问的其它数据，决定了他们各自行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都操存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析起在处理数据时会在后台使用它。

全局执行环境时最外围一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。对于全局执行环境来说，全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁。

控制ECMAScript程序中执行流的机制：每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止，如果找不到标识符通常会导致错误。

举一个🌰：

```javascript
var color = "blue";
changeColor();
console.log(color);
function changeColor() {
    if (color === "blue") {
        color = "red";
    } else {
        color = "blue";
    }
}
```

函数changeColor()的作用域链中包含两个对象：它自己的变量对象和全局函环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。

此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用。

```javascript
var color = "blue";
changeColor();
console.log(color);

function changeColor() {
    var anotherColor = "red";
    swapColors();
    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
    }
}
```

以上代码共涉及3个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。全局环境中有一个变量color和一个函数changeColor()。changeColor()的局部环境中有一个名为anotherColor的变量和一个名为swapColors()的函数，但它也可以访问全局环境中的变量color。swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。

无论全局环境还是changeColor()的局部环境都无权访问tempColor。然而，在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

函数参数也被当做变量来对待，因此其访问规划与执行环境中的其他变量相同。

### 4.2.1 延长作用域链

虽然执行环境的类型总共只有两种

- 全局
- 局部（函数）

但是，还是有其他办法来延长作用域链。

因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

- try-catch语句的catch块；
- with语句。

这连个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

```javascript
function buildUrl() {
    var qs = "?debug=true";

    with (location) {
        var url = href + qs;
    }
    return url;
}
```

with语句接收到的是location对象因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量qs。当在with语句中引用变量href时，可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于  with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。

### 4.2.2 没有块级作用域

Js没有块级作用域。Js中，在语句中的变量声明会将变量添加到当前的执行环境中。

#### 1. 声明变量

使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时**没有使用var声明**，该变量会自动被添加到**全局环境**。

#### 2. 查询标识符

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。

## 4.3 垃圾收集

Js具有自动垃圾收集机制。执行环境会负责管理代码执行过程中使用的内存。垃圾收集器会按照固定的时间间隔周期性滴执行垃圾回收操作：找出那些不再继续使用的变量，然后释放其占用的内存。

函数中的局部变量的正常生命周期。局部变量只在函数执行过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

### 4.3.1 标记清除

Js中最常用的垃圾收集方式是标记清除。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

可以使用任何方式来标记变量。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。然后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 4.3.2 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

 ### 4.3.3 性能问题

垃圾收集器时周期性运行的，而且如果被变量分配的内存数量很可观，那么回收工作量也是相当大的。于是，确定垃圾收集的时间间隔是一个很重要的问题。

### 4.3.4 管理内存

Js 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。最主要的一个问题，就是分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。主要是处于安全方面的考虑，目的是防止运行Js的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象属性。局部变量会在它们离开执行环境时自动被解除引用。











